## File Hash & VT Analysis

fca62097b364b2f0338c5e4c5bac86134cedffa4f8ddf27ee9901734128952e3 *Malware.stage0.exe.malz
6d8895c63a77ebe5e49b656bdefdb822 *Malware.stage0.exe.malz

VT Analysis: 46/68 Infected

According to VT it is a malicious binary

## Architecture 

32 bit binary

## Basic Static Analysis

### Strings & floss output

This binary didn't gave the interesting strings outright

### IAT & PE view

#### Windows API calls
- WriteProcessMemory
- VirtualAllocEx
- OpenProcess
- CreateRemoteThread

## Basic Dynamic Analysis

### Initial Detonation
On initial detonation when running without inetsim a window is opened very briefly. When detonating with inetsim a window is very briefly opened. No popups or other noticeable things.

### Host indicators
The binary is spawning a child process werfault.exe which is creating a new binary werflt.exe in C:\Users\Pubic path.
![6e27703093678063ef5d67fb28096f91.png](:/2277b9aa82ca48d5adb4a9591b5548fd)
![58dd2c842ecef59db5e5ac7bdcd4102d.png](:/40bc73925cbf46258f8ed88008913473)

### Network Signatures
The binary werfault is making a callback to the localhost at port 8443
![d8659ce3a207bc7c5eb0fb305f92c0f4.png](:/ff7262f6ffe6432e8a303faa6fb505a9)

This binary looks like a malware dropper, which is dropping the payload in the Public directory. And it is using process injection(hooking) to evade from AV.

Now analyzing the dropped payload werflt.exe in cutter.

![8a6593b495dbbf2773aa9907c0765a7c.png](:/2d89a91f363a410e90796086ab9e5060)

Looks like the classic process injection. It is making the API calls OpenProcess, VirtualAllocEx, WriteProcessMemory, CreateRemoteThread all these API calls are very common among the process injection binaries. I also observed that the arguments are also passed before the API calls which confirms it.

The binary is storing the process id in arg_ch. And it is copied to eax and passed to OpenProcess API as an argument. Again the process id is copied to edi and used in VirtualAllocEx API.

So in a nutshell we are opening a process with the OpenProcess which returns a handle to the process that can be used for the remaining API calls and then we are allocating an area of memory inside the process with rights to right. Then we are writing in the memory from the LPbuffer variable. At last it starts a thread in that remote process and tells the thread to go to this address which the address at which area of memory was created with read, write and execute permissions. 

### Process Hacker
Right after starting the binary werfault.exe is started in a suspended state. So while that spawns in a suspended state the rest of the program is kicked off. The PID of werfault is handed back to werflt. And so when werflt is executed it takes the PID of werfault
![a513862b34ecec1a8c503db75b0f91db.png](:/ccc281b1b1ea4612bd7e190e1304645f)

So if we open werfault and observer the memory allocation of it, we will see a section with RWX permissions which is very unusual for standard binaries.

![259ab6c83e733a061289a573345f7798.png](:/8d335e58791b4437a7d695b7580dfa98)

When we observer the memory we can see the shellcode written there. And when this is run it spawns the reverse shell
